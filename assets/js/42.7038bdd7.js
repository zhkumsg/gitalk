(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{181:function(e,s,t){"use strict";t.r(s);var a=t(0),r=Object(a.a)({},(function(){var e=this,s=e.$createElement,t=e._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"vue下是如何实现css私有作用域的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue下是如何实现css私有作用域的"}},[e._v("#")]),e._v(" Vue下是如何实现CSS私有作用域的")]),e._v(" "),t("p",[e._v("在web开发中，css是一个利器，它可以使得我们的页面更加炫酷华丽，但是在好用的前提下它也给迭代开发带来了一定的麻烦，比如样式相互覆盖或者样式影响到了未考虑的元素等，所以css的私有化就显得很有必要了。")]),e._v(" "),t("p",[e._v("但从严格意义上来说，css样式都是全局的，并不存在私有作用域这一说法，所以我们会通过各种各样的方式来模拟实现css的私有化。其中大部分都说基于"),t("a",{attrs:{href:"http://getbem.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("BEM"),t("OutboundLink")],1),e._v("思想来实现的。")]),e._v(" "),t("p",[t("strong",[e._v("css私有化的实现原则是匹配规则尽可能精确")]),e._v("。比如通过全局唯一的id来匹配或通过全局唯一的class来匹配，如每一个需要赋予样式的元素都添加一个独一无二的类名，然后只通过类名来书写样式，避免使用通配符、标签选择器和后代选择器等。")]),e._v(" "),t("p",[e._v("在css私有化领域中非常出名的是"),t("a",{attrs:{href:"http://getbem.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("BEM"),t("OutboundLink")],1),e._v("(Block Element Modifier)命名规则，它的主要思想是：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("只通过  块__元素--修饰符  来定义规则\n")])])]),t("p",[e._v("BEM的好处：清晰易懂，看到类名就知道作用是什么，方便维护；")]),e._v(" "),t("p",[e._v("BEM的缺点：丑、长(服务器开启gzip后会小一点)；")]),e._v(" "),t("p",[e._v("简单介绍BEM后，我们再看看vue下的实现。在"),t("strong",[e._v("vue")]),e._v("单文件组件下，我们只需要在"),t("strong",[e._v("style")]),e._v("标签上添加"),t("strong",[e._v("scoped")]),e._v("属性就可以实现css私有化的功能，那么它又是如何实现的呢？")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/13908708-b11b077bedc85133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e._v(" "),t("p",[e._v("未添加scoped属性前")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/13908708-1928f81857659084.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e._v(" "),t("p",[e._v("添加scoped属性后")]),e._v(" "),t("p",[e._v("可以清楚看到，添加scoped后，vue-loader加载器会做两个处理：")]),e._v(" "),t("p",[e._v("1、给html标签添加"),t("strong",[e._v("data-v-hash")]),e._v("属性"),t("br"),e._v("\n2、给css样式添加**[data-v-hash]**选择器")]),e._v(" "),t("p",[e._v("这样一来，css样式就只对带有相应data-v-hash的标签起作用了，也就变现实现了css作用域的功能。")]),e._v(" "),t("p",[e._v("当然，在开发过程中，也会遇到父之间无法操作子组件样式的问题（比如在自己的页面上用了element-ui的el-button组件）")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://upload-images.jianshu.io/upload_images/13908708-b4a3c143a9c57ca1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:""}})]),e._v(" "),t("p",[e._v("element-ui")]),e._v(" "),t("p",[e._v("如果父组件加了scoped属性，那么所以规则都会自动在最后追加data-v-hash选择器，自然找不到子组件的元素，此时我们需要把父组件的scoped去掉，或者使用深度作用选择器")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("<style scoped>  \n    .a >>> .b { /* ... */ }  \n</style>\n")])])]),t("p",[e._v("参考链接："),t("a",{attrs:{href:"https://vue-loader-v14.vuejs.org/zh-cn/features/scoped-css.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://vue-loader-v14.vuejs.org/zh-cn/features/scoped-css.html"),t("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);